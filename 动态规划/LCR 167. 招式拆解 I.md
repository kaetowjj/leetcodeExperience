# [LCR 167. 招式拆解 I](https://leetcode.cn/problems/zui-chang-bu-han-zhong-fu-zi-fu-de-zi-zi-fu-chuan-lcof?envType=study-plan-v2&envId=coding-interviews)

## 题目：
某套连招动作记作序列 arr，其中 arr[i] 为第 i 个招式的名字。请返回 arr 中最多可以出连续不重复的多少个招式。

示例 1:

输入: arr = "dbascDdad"
输出: 6
解释: 因为连续且最长的招式序列是 "dbascD" 或 "bascDd"，所以其长度为 6。
示例 2:

输入: arr = "KKK"
输出: 1
解释: 因为无重复字符的最长子串是 "K"，所以其长度为 1。
示例 3:

输入: arr = "pwwkew"
输出: 3
解释: 因为连续且最长的招式序列是 "wke"，所以其长度为 3。     
请注意区分 子串 与 子序列 的概念：你的答案必须是 连续招式 的长度，也就是 子串。而 "pwke" 是一个非连续的 子序列，不是 子串。
 

提示：

0 <= arr.length <= 40000
arr 由英文字母、数字、符号和空格组成。

## 解题思路：
滑动窗口的思路：
窗口的右边界（right）不断向右扩展：

在每次循环中，right 代表当前考察的字符下标，窗口范围从 left 到 right。
处理重复字符：

如果当前字符 arr[right] 已经存在于 window（通过 window.count(c) 判断），就会触发 while 循环。这时窗口中的字符有重复，需要缩小窗口的左边界。
通过 window.erase(arr[left])，我们移除 left 所指向的字符，并且将 left 向右移动，直到窗口内不再有重复字符。
窗口的扩展和更新：

当窗口内不再有重复字符时，加入当前字符 arr[right]，并更新 window，同时比较窗口的长度是否是最大值。
总结流程：
右边界 right 不断向右延伸，不断扩大窗口。
如果发现窗口内有重复字符，则通过移动左边界 left 向右缩小窗口，直到窗口不再有重复字符。
每次找到一个没有重复字符的窗口后，更新最大长度 ans。
这个过程就像是一个向右延展的窗口，随着窗口的右边界不断向右扩展，只要窗口内出现了重复的字符，左边界就会往右收缩，确保窗口内的字符始终是唯一的。

具体例子：
假设输入字符串是 "abcabcbb"，让我们逐步跟踪这个过程：

初始：left = 0，right = 0，窗口为空。
right = 0，字符 'a'，加入窗口，window = {a}，ans = 1。
right = 1，字符 'b'，加入窗口，window = {a, b}，ans = 2。
right = 2，字符 'c'，加入窗口，window = {a, b, c}，ans = 3。
right = 3，字符 'a'，发现窗口中有重复的 'a'，于是开始收缩左边界，移除字符 'a'，left = 1。
right = 4，继续延展，依次处理字符，直到右边界扫描完字符串。
最终，算法找到没有重复字符的最长子串。

这个过程就是一种不断向右延展窗口，然后遇到重复字符时收缩窗口的策略。

### 代码
```c++
class Solution {
public:
    /**
     * @brief 计算字符串中没有重复字符的最长子串长度
     * 
     * 该函数采用滑动窗口技术，动态维护一个窗口（子串），保证子串中没有重复字符。
     * 通过右边界不断扩展子串，同时通过左边界缩小窗口，确保没有重复字符的子串是最长的。
     * 
     * @param arr 输入字符串
     * @return 返回没有重复字符的最长子串的长度
     */
    int dismantlingAction(string arr) {
        int n = arr.length();  // 获取字符串的长度
        int ans = 0;           // 保存结果，即最长子串的长度
        int left = 0;          // 左边界，初始为 0
        unordered_set<char> window;  // 维护从下标 left 到下标 right 的无重复字符集合

        // 右边界从 0 到 n-1，依次遍历字符串
        for (int right = 0; right < n; ++right) {
            char c = arr[right];  // 获取当前右边界字符

            // 如果当前字符已在集合中，则意味着窗口内有重复字符
            // 通过移动左边界 left，直到移除重复字符
            while (window.count(c)) 
                window.erase(arr[left++]);  // 移除左边界字符，缩小窗口

            // 将当前字符插入集合，继续扩大窗口
            window.insert(c);

            // 更新最长子串的长度，当前窗口的长度为 right - left + 1
            ans = max(ans, right - left + 1);
        }

        // 返回最长子串的长度
        return ans;
    }
};

```

### 复杂度分析：
时间复杂度：O(n)，其中 n 为 s 的长度。注意 left 至多增加 n 次，所以整个二重循环至多循环 O(n) 次。
空间复杂度：O(∣Σ∣)，其中 ∣Σ∣ 为字符集合的大小，本题中字符均为 ASCII 字符，所以 ∣Σ∣≤128。

## Reference
1. 参考来源作者：灵茶山艾府
2. 链接：https://leetcode.cn/problems/zui-chang-bu-han-zhong-fu-zi-fu-de-zi-zi-fu-chuan-lcof/solutions/2181636/yi-xie-jiu-cuo-qing-kan-zhe-pythonjavacg-31u3/
